#könyvtárak importálása
import cv2
import numpy as np
from skimage import feature
from skimage import io
import matplotlib.pyplot as plt
%matplotlib inline
from time import localtime, strftime


#kép beolvasása és szürekeárnyalatossá alakítása
be="kiber.png"
im = cv2.imread(be)
im = np.array(im, dtype=np.uint8)
im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)

#kimenet:szövegfájl
ki=be.split(".")
ki=ki[0]+".txt"
file = open(ki, "w")
#file.write(strftime("%d-%b-%Y-%H.%M.%S---", localtime()))
#file.write(ki)
#file.write(":")
file.write(str(im.shape[0])+";"+str(im.shape[1]))
file.write("\n")


#élkeresés
edges = feature.canny(im)
#élek megjelenítése
plt.imshow(edges,'gray')
plt.show()

#nemzérus pixel kereső függvény
def keres(kep):
    k=0
    kp=np.zeros((2,1))
    for i in range(0,kep.shape[0]):
        for j in range(0,kep.shape[1]):
            if kep[i,j]==1 and k==0:
                kp[0]=int(i)
                kp[1]=int(j)
                k=1
                
    return kp


##alap paraméterek megadása: kezdőpont inicializálása
kezdopont=keres(edges)
kovpont=[int(kezdopont[0]),int(kezdopont[1])]
file.write(str(kovpont))
file.write("\n")
file.write("[-1,0]")
file.write("\n")


#átalakítás. a while azért végtelen, mert úgyis kilép
while 1:
    p0=int(kovpont[0])
    p1=int(kovpont[1])
    #aktuális pixel törlése
    edges[p0,p1]=0
    
    
    #ha megszüntetjük a kommentelést, minden lépést kirajzol.
    '''io.imshow(edges)
    io.show()
    '''
    
    
    #kovpont inicializálása hibás adattal. a [-1,-1] a hibás adat, amit nem szeretünk. [0,-1]:toll fel, [-1,0]:toll le
    kovpont=-np.ones((2,1))
    
    #első típus: a következő pont az előző alatt/fölött/mellett van
    if edges[p0-1,p1]==True:
        kovpont=[p0-1,p1]
    elif edges[p0+1,p1]==True:
        kovpont=[p0+1,p1]
    elif edges[p0,p1-1]==True:
        kovpont=[p0,p1-1]
    elif edges[p0,p1+1]==True:
        kovpont=[p0,p1+1]
    elif edges[p0-1,p1-1]==True:
        kovpont=[p0-1,p1-1]
    elif edges[p0-1,p1+1]==True:
        kovpont=[p0-1,p1+1]
    elif edges[p0+1,p1-1]==True:
        kovpont=[p0+1,p1-1]
    elif edges[p0+1,p1+1]==True:
        kovpont=[p0+1,p1+1]
    
    #második típus: nem közvetlenül mellette van, de max 1 zérus pixel van köztük(pl hibás kép)
    elif p0>2 and p0<edges.shape[0]-2 and p1>2 and p1<edges.shape[1]-2 :
        for i in range(p0-2,p0+3):
            for j in range(p1-2,p1+3):
                if edges[i,j]==True:
                    kovpont=[i,j]
    
    #kiírás
    if kovpont[0]!=-1 or kovpont[1]!=-1:
        file.write(str(kovpont))
        file.write("\n")
        
    #harmadik típus: nincs a közelben nemzérus pixel, újat keres (ilyenkor kell tollfelemelés)
    else:
        k=int(keres(edges)[0])
        l=int(keres(edges)[1])
        #feltétel a befejezésre. ha nem talál újat, kilép. A [0,0] azért lehet kilépési feltétel, mert ez a legelső pont,
        #amit vizsgál a keresőfüggvény, tehát az első lépésnél már bejártuk, ha létezik 
        if k==0 and l==0:
            file.write("[0,-1]")
            file.write("\n")
            #nullázás
            file.write("[0,0]")
            file.write("\n")
            break
        #ha talál újat, itt folytatja
        else:
            kovpont=[k,l]
        
        file.write("[0,-1]")
        file.write("\n")
        file.write(str(kovpont))
        file.write("\n")
        file.write("[-1,0]")
        file.write("\n")

    
file.close()
